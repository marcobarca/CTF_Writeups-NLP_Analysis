Writeup_name,Category,Text,Label,Topic,Topic Label
XMarkTheSpot,web,"The idea is similar to SQL injection. 
We have a vulnerable query for authenticating the username and password which should be similar to.
So, if we inject some valid XPATH vocabulary into the query, we can manipulate it.
",analysis,0,Topic 0
Members,web,"If we leave the search query empty, we would see all members, else it filters the name.
",analysis,0,Topic 0
05_Cursed_Secret_Party,web,"Looking into the burpsuite proxy, it is posting data to the submit endpoint.
Tracing into the source code, this endpoint adds the post data in the database and calls a visit function from bot. The other endpoint is /admin which gets the data from db and passes it into the admin template and /admin/delete_all endpoint deletes all the data from db.
Looking into the visit function which is called when we submit the form. It first creates a headless browser and it signs and sets an admin JWT which contains flag. This gives the idea that we need to steal this admin cookie. Then it visits the /admin page which displays all the data from db and then it calls delete_all endpoint which deletes all data from db.
Now, that we know that we need to steal admin cookie and also the admin is rendering the user input data, we can perform XSS to grab the cookie.
Looking in the admin template which displays the form data to admin, the halloween name field is marked safe which means it will not escape character, so we can inject our js code in it.
But the problem is that it has a CSP header which we need to bypass for our XSS to work. Understanding the CSP that script source is set to self and jsdelivr CDN which means it will only trust JS code from itself or the cdn.
Fortunately this CDN lets us load files from github and other sources. Which means that we can bypass the CSP and perform our XSS.
So, the idea is to make repo on github and upload the js file, which contains our payload, on it. Since we need to grab the cookie, we add a new image tag and set the source to our own link which logs the request and then append the cookie in the get request. Here i am using webhook.site.
",analysis,0,Topic 0
High_Security,web,"Instead of the path /members, this time we have /security. 
The security page shows an empty table with the columns IP and time.
Since the description tells us that we can see when someone tries to log into our account, we tried to log into our account with a false password. 
Voilà — an entry appears in the table showing my IP address (this is obviously not really mine) and a timestamp.
The table shows the IP address of people who tried to break into your account.
",analysis,0,Topic 0
27_Forbidden_Paths,web,"With file paths, a preceeding ./ means the current directory, and ../ means the enclosing directory. 
",analysis,0,Topic 0
28_Power_Cookie,web,"If we go to the website, we find that there are no cookies saved. However, if we click the continue as guest button, we see that a cookie with the name isAdmin is generated, with the value 0.
",analysis,0,Topic 0
22_Web_Gauntlet_2,web,"We know that the username field must be ""admin"" but unfortunately this is filtered. To bypass this we can simply use the ""||"" joiner with a final value for the username field of ""ad'||'min"".
For the password field we must simply provide something that returns true. The most common one used is ""' OR '1'='1"" but OR is filtered as seen in the filter.php file. Instead we can craft a true statement using IS or IS NOT such as ""a' IS NOT 'b"" which is also true but does not use anything in the filter.php file.
",analysis,0,Topic 0
05_Some_Assembly_Required_1,web,"After inspecting the website, you can see there's a G82XCw5CX3.js file. I visited mercury.picoctf.net:55336/JIFxzHyW8W which consisted of this.
The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. './JIFxzHyW8W' is a path.
",analysis,0,Topic 0
BigHug,web,"When starting on a CTF challenge, the first thing I do is to look for a destination. 
Getting access to a repository that you don’t own should be impossible because the permission controls for repositories are very simple and on first glance, has no obvious problems. 
However, there is a caveat in that if you make requests from a loopback IP address, you will be given essentially godmode powers so you can access any repository. 
It’s clear here that our goal is to somehow make requests from a loopback IP address, hinting at some kind of server-side resource forgery (SSRF) exploit.
git-receive-pack is the endpoint that is used by Git to perform remote operations on a repository. 
In other words, when you git push, the CLI converts your changes into a pack and POSTs it to the server.
BigHug has functionality that lets you specify POST webhooks that will be triggered when you make changes to a repository (more formally, it does this when it executed as git-receive-pack command). 
You are able to provide it with a URL, content that you would like to POST to that URL as well as the Content-Type of the content. 
The content that you provide is then put through a simple templating engine that allows you to inject certain attributes of the commit into your webhook. 
I’ll go more in depth on this below where I explain how the exploit works.
",analysis,0,Topic 0
21_Some_Assembly_Required_3,web,"After inspecting the website, you can see there's a G82XCw5CX3.js file. I visited mercury.picoctf.net:55336/JIFxzHyW8W which consisted of this.
The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. './JIFxzHyW8W' is a path.
I visited mercury.picoctf.net:55336/JIFxzHyW8W and it gave a WebAssembly file.
I translate the wasm file to wat and analyze the result.
Now I translate to pseudo-code and analyze the result.
We can see that check_flag stayed pretty much the same as last time, so we can assume that the magic happens in copy. If we diff it against the original implementation (which simply stored the provided flag characters in memory without any extra manipulation) we can see that this version includes some extra logic:
Notice that e[2] comes from b which is the index of the character, and e[3] comes from a which is a user input character. We can also see that this implementation is using an extra array defined at offset 1067+:
",analysis,0,Topic 0
11_Who_are_you,web,"There are many ways to approach this (some alternatives are curl and burp suite) but I ended up using Postman's HTTP request. We'll unhide requests and override the default User-Agent request with a PicoBrowser agent.
Now, we need to make the header show it's from the same site. We'll use a key of Referer with a value of the site
We'll use the Date header with any value from 2018, for example ""1 Jan 2018""
We can set DNT which is ""do not track"" to 1 (true).
We can use the X-Forwarded-For which will change the originating IP address. Grab any random IP address from Sweden like 12.16.66.01
We can use the Accept-Language header to specify which languages are ok. We can look through a list of languages and find Sweden's subtag is sv.
",analysis,0,Topic 0
12_login,web,"However, it’s a lot simpler than that. After navigating to website source, we encounter index.js. Upon pretty-printing, it’s just vanilla JS.
The important part of the code is in line 12, where it’s checking for a username and password that has been turned into Base64 from ASCII via the btoa() method, which is reversible with the atob() method. The password itself is the flag when decoded. Opening the console and undoing the encoding, shown below, results in the flag.
",analysis,0,Topic 0
02_Spookifier,web,"Looking into the source code reveals that it’s a flask app and using mako template engine for rendering. On line 11, the user input is passed into the spoofiky function and it’s output is passed into the template.
Tracing the spookify function, it passes the text onto change_font function which just maps the text characters againts different font dictionaries.
One font dictionary does not have any unique character for mapping.
Since, the user input is directly passed into the template with any sanitization, this introduces the Server Side Template Injection (SSTI).
We confirm it by using the following payload and it sucessfully evaluates it.
",analysis,0,Topic 0
25_Web_Gauntlet,web,"Level 1 - filter: or
Use basic injection and comment out the rest of the line.
Level 2 - filter: or and like = –
Without --, check for other ways to comment. We can also use UNION to get our specific user.
Level 3 - filter: or and = like > < –
The first injection from the previous round still works here, but let’s try to get the second to work too. Spaces are now blocked, but we can use /**/ comments for the same effect. I tried %20 to replace all the spaces, but it was not effective.
Level 4 - filter: or and = like > < – admin
In SQLITE, || is a concatenation operator. The simple solution is to simply split up “admin” in a way to bypass the filter. A more complicated solution could include encoding encode “admin” in ASCII number code and using the SQL CHAR() function to decode it.
Level 5 - filter: or and = like > < – union admin
Splitting up “admin” still works as only UNION is additionally blacklisted.
",analysis,0,Topic 0
Homework,web,"A bit of googling shows that port 6666 is unsafe and must manually be allowed. In Chrome, this is possible via the option —explicitly-allowed-ports=6666 , in Firefox we can add the option network.security.ports.banned.override with the value 6666 in about:config.
Afterwards, we can see a homepage with one input field to enter our homework.
The webpage has one input field.
If we enter Markdown or HTML it would render it as HMTL.
The result of the rendered homepage.
We soon found out that it was rendered with Pandoc as it stands in the webpage source and that we could enter an external source to be contained in the rendered output. For instance, if we submit a script tag with our controlled URL, we could see the content of the URL in the response from the server. This means, the request takes place on the server and not on the client. The Pandoc documentation refers to this as the — self-containedoption.
We can see the Hello World content of our URL loaded in the response from the server.
",analysis,0,Topic 0
Notepad,web,"We were provided a source so I checked that out. I first noticed the filters on the note’s content.
The filter on / indicates that path traversal should be prevented. However, the created file’s name looks odd.
The filename is the first 128 characters of the content and a random token. 
It’s a bit weird that they’re normalizing the path with url_fix(content[:128]); that’s our first vulnerability. 
Even though / is filtered, \ is not, and url_fix() would normalize the backslashes to be /. We could use this to traverse the filesystem.
Arbitrary Template Creation
Remember that error from the filter on content? That comes in handy now. On the index page, the error can be set to any arbitrary value by simply passing in another value to the error query parameter:
This value is then used as the filename for a Jinja template in the errors subdirectory.
How is this useful? Well, we can create our own error template by using our path traversal technique to create a file in the templates/errors folder. 
This new template can then be rendered on the index page if we pass it in as a query parameter.
",analysis,0,Topic 0
Authentication,web,"Of course, we could try various SQLi techniques, but here, already the first SQLi textbook exploit works: ‘ OR 1==1-- as username logs us in as admin.
",analysis,0,Topic 0
Note,web,"The source code was available to download. 
Let's look at what's going on in the backend. 
web.js has all the endpoints and the server is run internally on localhost:8080. 
However the most interesting part is report.js which handles the /report endpoint. 
Let's look at its code.
Couple of things to notice here:
It's a puppeteer bot.
It is a headless, no-sandbox chromium browser (it's infamous of lax security).
The bot creates a new account with completely random username and password. 
Creates a new note with content as process.env.flag i. e the flag. 
The bot in the end opens the url we provide on the /reports page.
The ideal plan would be to read the contents of ""My notes"" of the bot account which includes the flag. 
I had several ideas like use fetch API to login to a test account and create a note with contents from the bot account but the csrf library used was making it very tricky to do that. 
After some manual testing I figured that you can access internet through the puppeteer bot.
Now this opens a lot of possibilities. 
I can make a get request containing the ""My Notes"" contents as an argument.
",analysis,0,Topic 0
15_Local_Authority,web,"To find out more about the inner workings of the website, we look at the source code (right-click on the page) and find the following:
Nothing visible at first sight. We dive deeper and look at the files style.css and login.php. There is nothing special in style.css, so we focus on login.php:
Three further files are referenced in this document: style.css, admin.php and secure.js, and there is some JavaScript code included in the website directly (starting in line 19 with <script type=""text/javascript"">.
The function filter obviously checks if the entered field contains only allowed letters. The JavaScript code following the function definition reads the entered values and passes them on to a function called checkPassword() which is not defined in this document. Since we are looking for JavaScript code, we look into secure.js first and find the following:
",analysis,0,Topic 0
03_modernblog,web,"The first thing I can think of is XSS to account take over. However, as the comment says, there is CSP set at server.
According to the CSP, there is no room for our custom script to run on the website, which means the account takeover approach is impossible.
At this point, there is only 1 option left: get the flagId of the admin post, which is in /home page of admin user!
However, it does not directly HTML encode special characters, so we still can inject markup, HTML, CSS. But what we can do with this? What about CSS Injection / XS-leak? We can inject CSS into the post body, but it will execute on post page, while the flagId is in the /home page. So, what else we can do with HTML and CSS?
Just hold down a little bit. Although we can't execute our custom script, is that means we have no control over JS execution of the web? The answer is NO! We can do that with DOM clobbering attack.
DOM clobbering is a well-known attack to change a value of window properties. For example:
However, reading the author writeup, I now know that DOM clobbering is only able to the the value of window properties, but also document properties! The key point is here
So, the first point tells us that for any exposed embed, form, iframe, img, or exposed object element, the value of the “name” attribute will be a property of the Document object.
Okay, but how to use this technique to solve the modernblog challenge? To use this, we need to answer a critical question:
What property needed to be changed in order to change behavior of the modernblog web app?
To figure out that property, we need to understand the how the web app works in depth. And, it will lead us to me to React Router!
At the main.jsx file, we can see this application is route using the BrowserRouter. It actually a single page application, and it will choose which page to render based the path property.
Take a look at BrowserRouter doc, there is a line worth noticing
<BrowserRouter window> defaults to using the current document's defaultView, but it may also be used to track changes to another window's URL, in an <iframe>
That is, document.defaultView, right?
The doc also state that BrowserRouter ""browse using the built-in history stack"", so taking a look at the History API can help us confirm whether document.defaultView is what we are looking for. And it is!
At this point, we know that the key point of this challenge is the document.defaultView property. Let's test DOM clobbering payload at the modernblog website whether it work or not.
Isn't that magic. It clobbered! With that, we can now open the /home page, and perform CSS Injection to leak the flagId!
But, how to make the createBrowserHistory run again? If not so, there is no /home page loaded, hence no bit leaked.
The createBrowserHistory only run when the application load, but we can't make the modernblog web reload. Even if we could do, we would not like to do this as our payload will go!
That go to a super cool idea of this challenge: create a React app inside a React app
",analysis,0,Topic 0
03_modernblog,web,"The text color is red, and the content is exactly of the /home page. We finally reach the point! Load the /home page, inject CSS to leak the flagId bit by bit to get the flag!!!!!!!!!
",analysis,0,Topic 0
LiveArt,web,"Looking closer at what happens when you submit a link (this is in the code directory under “server”), we learn that the flag we are looking for is stored in the browser’s local storage for the live-art website, under the key ""username"". 
All we have to do is figure out how to leak that information from a client that clicks on our link.
We can provide the “victim” a link. That means we are fundamentally in control of one thing: a URL. 
We start out wondering if there’s anything on the website where the url has a direct impact on the rendered HTML (or javascript). 
It doesn’t take long for us to find the /error route, which is backed by this ErrorPage component.
In particular the useHashParams function stands out to us. 
Whatever that function returns influences a link and the content of an h3 block. So, what does useHashParams do?
Aha! This is interesting. There’s some state being stored inside React, and that state is an object constructed by iterating through the hash parameters and storing the key/value pairs. This means that navigating to a url like /error#returnTo=/foo&error=Error%20Message will give us a page containing an <h3> “Error Message” and a link to the page /foo (try it!). However, React is very good about escaping these inputs, so it’s not directly vulnerable to XSS. We can inject a ""javascript:"" link, but we can’t actually get the headless browser to click it, so it’s not directly helpful to us.
We do notice that is a suspicious loop, and we initially wondered if it might be vulnerable to a prototype pollution vulnerability, but it didn’t seem like it after some testing.
This ErrorPage component was the only obvious “source” for us to inject content in the URL and have it end up influencing the DOM / javascript. 
We also looked into the “live-art” broadcast feature, but the incoming data from peers was only used to influence an <img> src data, so it didn’t seem possible to inject javascript that way.
We take a break from looking at sources and try to find sinks - these are places where javascript variables might end up affecting the dom. 
In particular we’re interested in being able to directly inject html elements (like <script>), or possibly some element attributes (onload, onerror and the like). 
One of the most common ways this might happen is the use of the ... spread operator, as that could unintentionally include unintended state.
Let’s grep for it:
Hmmm… It’s a reducer with an initial value of baseResolution and some logic adjusting width/height. 
In general it seems that it only ever works with the width and height properties, so it’s not obvious how we could inject a more interesting attribute, like the classic onerror attribute often used on img tags for XSS.
The javascript on the live website has been bundled/minimized and doesn’t lend itself to debugging. 
Fortunately we have the source code, but not really any instructions on how to use it. 
Since we’re only interested in the client code right now, let’s try and host that code ourselves, hopefully with source maps for ease of debugging. 
To do that, we’ll whip up a Dockerfile, based largely on the one they gave us for the noted challenge.
This Dockerfile contains some unnecessary components (we need puppeteer for the server project, but not client).
In any case, it’s good enough for now. Build it with the tag picoctf2022-liveart and run it like this.
This will give us a development server running on port 3000. 
Loading it up, we are again greeted with the live-art website, but this time dev-tools has working source maps, and we can even use breakpoints.
At this point we’re a bit out of ideas. We have a source (the ErrorPage component), and a sink (the Viewer component), but individually they appear benign. 
We load up the development server and start poking around for something we missed.
After poking around for a bit, we stumble across the Drawing component. 
This component appears to reference both an ErrorPage component and a Viewer component. 
It’s used if you go to a valid /drawing route, such as /drawing/abcd. 
The logic seems to be that if the window is too small then the error component is used, and if the windows is large enough then the viewer component is used. 
The use of these two components together on the same page is setting off alarm bells in our heads, but how can we exploit it?
One thing we notice is that if we’re on the /drawing/abcd page and we resize the window small enough, the javascript console starts spitting out error messages. 
This is something we didn’t see on the release version of the website, so it must be something to do with the fact that we’re now using React in “developer” mode. 
At this point we’re pretty sure we’ve found the vulnerability. But what is it?
Since we know the ErrorPage component will read from hash parameters, let’s load up the drawing route in a window that is really small, so that it starts with an ErrorPage component. 
Navigating to /drawing/abcd#error=abcd with the window small doesn’t initially seem to do anything. 
It doesn’t even override the displayed error message. 
However, if we now resize the window so that it’s large, something interesting happens.
In addition to the error message in the javascript console, inspecting the DOM now reveals this element:
Aha! That state that the ErrorPage component uses must be getting re-used in the wrong context. 
It replaces the dimensions variable in the Viewer component, allowing us to inject attributes on the <img> tag.
Let’s try that again, but this time with /drawing/abcd#src=1&onerror=alert(1). 
Remember, the window has to start out small and then be resized larger.
Unfortunately, that doesn’t work.
React is pretty specific about it’s handlers. 
In general it expects you to provide things the “React” way rather than using raw javascript. 
It even requires the onError attribute to be a function and not a string, so simply adjusting the case in our URL doesn’t help. 
We start banging our heads against the wall, since we’re so close to cracking this thing.
Desperately researching React XSS vulnerabilities, we come across this article from a 2021 CTF writeup. 
It reveals the secret: if your object has an ""is"" property, then react will treat the whole thing as a WebComponent and pass the attributes straight through. 
Let’s try it out: /drawing/abcd#src=1&onerror=alert(1)&is (remember, start with the window small and then resize it so that it’s larger).
Success - we are greeted with an alert popup! 
",analysis,0,Topic 0
01_Evaluation_Deck,web,"Intercepting the requests with burpsuite, when selecting a card, post request is sent to /api/get_health endpoint with three parameters as shown below.
In response, remaining health is sent.
Looking into the source code, the three POST parameters are directly passed into the compile function which creates code format for exec function. The exec function in python allows to execute arbitrary python code. So, the lack of input validation means we can inject arbitrary code in this function and execute it.
",analysis,0,Topic 0
JavaScriptKiddie,web,"Looking at the source code of the website, we see a script that seems to be constructing our image by manipulating some values in an array named ""bytes"", and our input, otherwise called key in the code.
We get the bytes array through the browser console.
The script seems to be doing:
Use the input as the key
For each number in the key, convert the string to the actual number(char()-48), store it in variable i.
Get the byte value for the resultant PNG at position (i , j), by the following formula.
Remove all trailing zeros from the file.
Use the result as the source for the PNG displayed on the page.
Looking at the file signature for a PNG file, we see that the first 8 bytes of the file have to be 89 50 4E 47 0D 0A 1A 0A, and the trailing 8 bytes have to be 49 45 4E 44 AE 42 60 82. 
",analysis,0,Topic 0
01_Pirate_birthday_planner,web,"The query is vulnerable to noSQL injection, but we need to set both session.user and session.pin to a js object controlled by us.
The session is stored in a cookie created with the cookie-session library and it needs a signature with a random key, so we should find a way to get it from the server.
When using the app in the intended way the browser sends the requested data with Content-Type: application/x-www-form-urlencoded. However, the server also loads a middleware to interpret the application/json content type.
",analysis,0,Topic 0
01_Pirate_birthday_planner,web,"However, this endpoint calls the trim() function on the user parameter making it unusable for the exploitation.
We need to set both session.user and session.pin to an object to bypass the checks.
We used two sessions in parallel to get the exploit working, a legit session and a session for the payload.
First we create a party in the legit session with valid values.
Then, in the other session, we create a party sending the admin parameter equal to the object {""$ne"":""a""}. The creation of the party will fail, but the session values are updated anyway, in this way we set session.user to the bypass object.
However, we have a random value in session.pin, but we can’t change it because the corresponding party doesn’t exists in the server.
To solve this problem we set the pin of the legit party equal to the one in the payload session.
",analysis,0,Topic 0
02_Cookies,web,"Let's check the cookie we get from the server:
What if we try to access with a different cookie name?
",analysis,0,Topic 0
29_Roboto_Sans,web,"The text in here disallow looks suspicious.
The double equal sign suggests that it's base 64. However, if we try to decode it with an online decoder, it seems like the base 64 is a little malformed. As the base 64 text spans across three lines, it suggests that it is actually three separate strings.
",analysis,0,Topic 0
26_Some_Assembly_Required_4,web,"The basic flow of the challenge is that you enter in a flag and it checks if its the correct flag.
The JavaScript on the page interacts with a WASM program by first copying over each character in the flag into memory using the copy_char() function. Afterward, it calls check_flag() and receives a boolean, depending on whether the flag was valid or not.
Reverse Engineering
Google Chrome has one of the best tooling suites ever. This extends to WASM, where there is a debugger that disassembles the compiled WASM binaries into WebAssembly Text Format (WAT) and allows you to add breakpoints wherever you want. Thus the process of vaguely figuring out how it works is quite simple: all you need to do is to put breakpoints where you think something happens and you can inspect local variables at that breakpoint.
My process was even more simple. I was able to identify that the code was looping through the entered value (by putting in picoCTF{ as a prefix and putting random characters afterward) and returning when a character didn’t match. For this specific challenge, it compares two characters at a time, in contrast to the previous challenge which only compared one at a time.
(Smart) Brute Force
The fact that this is a short circuit allows us to do a side channel attack on the checking process. To speed this up, we can add snippets of code that increments a counter whenever you get a character correct and resets that counter whenever you call the function. Knowing how many characters we got correct allows us to brute force the flag two characters at a time.
You can see now how this now reduces to brute forcing two characters at a time, since we can start with guessing the first two. After we know those two characters are correct, we can guess the next two, then the next two… until we get to the end.
The only issue now is how we’ll add the code in. I don’t know how to write WebAssembly at all, and learning it seemed to be quite a steep curve. Instead of writing the WASM code myself, I found that you can compile C to WASM and then just copy those code snippets. I used WasmFiddle for this purpose.
The part that declares the memory location for the global variable is (data (i32.const 16) ""\00""), and its clear that the offset of this memory location is 16. We can change this to whatever we want as long as we change the appropriate offsets in the rest of the code.
We also want to reset the global variable between runs, so I also compiled a snippet that set the variable to 0.
I identified a suitable location to add the code snippets, which is right after a eq operation in the program. Using the information gained from putting a breakpoint there, I could tell that the inserted code would only run if the character matched.
Since the WASM code is really long, I’ve uploaded them as files. You can see the final patched WAT file here and the diff between the original and patched here, I used an offset location of 3000 in my patch. I used the WebAssembly Binary Toolkit (WABT) to disassemble and reassemble the original binary.
",analysis,0,Topic 0
26_Some_Assembly_Required_4,web,"Not being great at reverse engineering was for me a blessing, because otherwise I would have spent a lot of time and effort attempting to understand what the code was actually doing. Not being familiar with it gave me a different perspective, which allowed me to conceptualize a much easier solution to the challenge. I think this challenge was quite interesting, if not a bit misplaced given that it had very little to do with Web Exploitation.
",analysis,0,Topic 0
30_Secrets,web,"If we right click -> inspect and look at the sources tab, we find that some of the assets are in a suspiciously named folder called ""secret"".
If we navigate to the secret suburl, we find a website that says ""Finally. You almost found me. you are doing well"".
We are on the right track. If we repeat the same process as before, we find that there is another suspiciously named folder, ""hidden"", so we navigate to it. 
We keep on repeating this process until we reach a website that says ""Finally. You found me. But can you see me"".
",analysis,0,Topic 0
03_Horror Feeds,web,"Looking into the provided zip file, there’s the docker startup script which creates the users table and add the admin user entry. The password is hashed.
Next, the flag is loaded in the flag attribute of config class.
Then, this flag and authenticated username is passed into the dashboard template. But, we saw the dashboard after but there was no flag.
The reason is that there’s a condition in the template that flag will ony be rendered when admin logs into the dashboard.
This means that we need to be admin to get the flag.
Looking in the register function, the username is directly passed to the SQL query without any sanitization. This introduces the SQL injection. First query on line 30 doesn’t concerns us because the passwords are hashed and we already have hash of admin password but it’s of no use. But the second query of line 36 is interesting.
Since, this an insert query and there’s no input validation, we can use it to change the admin’s password hash to our own generated hash.
This can be done by using the ON DUPLICATE KEY UPDATE which is an extension to insert statement that, if it finds a duplicate unique or primary key, it will instead perform an update.
So, the logic is to try to add admin user which we know already exists in the table, so on duplicate key, we can change it’s hash. You can read more about it on the following page:
The application uses bcrypt with 12 rounds to hash the password. So, first we generate a new hash of our own password.
",analysis,0,Topic 0
Lightweight,web,"We can see that the closing bracket breaks the LDAP filter, thus we can probably inject more filters.
Furthermore, when we click in Our team the webpage tells us that they have four users, three developers and one admin.
The webpage has three developers and one admin
After some tries with the given emails and other input, we came to the conclusion that we can get three outputs:
An error message “No such user !” when the request was correct, but LDAP found no user with our given filter. For example, email foo@bar.de cannot be found.
An error message “Invalid username/password !” when the request was correct and LDAP found the user, but our password was not correct. For example, email jdoe@dvctf.local works fine.
An error message “Invalid username/password !” plus the PHP error messages when the request was broken. For example the closing bracket.
",analysis,0,Topic 0
Lightweight,web,"Searching on the internet for brute force methods against LDAP’s userPassword led us to another writeup with exactly the same problem.
The userPassword is an octet string and thus cannot be brute-forced the same way as a normal string. 
However, we can use other operators on the userPassword, for instance, octetStringOrderingMatch. 
To do so, we only need to add the OID of octetStringOrderingMatch 2.5.13.18 behind userPassword and can brute-force byte values, like in the payload below.
",analysis,0,Topic 0
03_Insp3ct0r,web,"Visiting the website, we right click and choose to view source code, getting the first third of the flag, included as a html comment:
The second part of the flag comes from the referenced CSS file mycss.cs:
The last part comes from the Javascript scipt myjs.js:
",analysis,0,Topic 0
04_Juggling_Facts,web,"Looking at the burpsuite proxy, under the hood it is sending post request to getfacts endpoint with the fact type parameter.
Looking into the source code, the getfacts endpoint is controlled by getfacts function.
The getfacts function basically have two main things. First there’s an if statement that checks if the request fact type is secret and the request is not coming from localhost then return the message that we saw earlier in the response. I tried to bypass this localhost condition by it didn’t work.
Second there’s a switch statement which checks the type and returns the facts. Personally, i have not seen much switch statements so i had no idea but on some research i found that this was vulnerable because of type juggling.
PHP has a feature called type juggling. This means that during the comparison of variables of different types, PHP will first convert them to a common, comparable type.
Basically, the switch statements in php use loose comparision (==). Following image shows the structure of switch statements in php.
Looking at strings loose comparisions, the condition can be true when providing the same strings or a true (boolean value).
""secret""==""secret""  -> true
""secret""==true      -> true
",analysis,0,Topic 0
18_Super_Serial,web,"We can access index.phps to find the following:
The above php code points us in the direction of authentication.php. Looking at authentication.phps shows the following:
The above php code points us in the direction of cookie.php. Looking at cookie.phps shows the following:
Finally, the require_once() includes the cookie.php file. Let's view the source code:
OK. A few things to note here. The cookie.php file is included in every page. The following code segment will deserialize our cookie and print the object when an error occurs. (""Deserialization error. "".$perm)
Conveniently, the access_log class in authentication.php has the following __toString() method:
__toString is one of the PHP magic methods that override PHP's default behaviour. This method is called when the object is converted to a string. So if we could get the above $perm variable to be our custom access_log object, we could achieve arbitrary file read on the target system.
",analysis,0,Topic 0
Obfuscation,web,"As we don't know the secret, we first look into the source code of the webpage and see obfuscated Javascript.
",analysis,0,Topic 0
10_It_is_my_Birthday,web,"I searched up ""MD5 collision"" and eventually found this website. 
It provided 2 executable files (hello and erase) which have the same MD5 hash. I downloaded those files and changed the extension to a .pdf file.
",analysis,0,Topic 0
17_Some_Assembly_Required_2,web,"After inspecting the website, you can see there's a G82XCw5CX3.js file. I visited mercury.picoctf.net:55336/JIFxzHyW8W which consisted of this.
The first time I looked at it I gave up in 5 seconds. Anyways, in the const declaration one of the elements caught my attention. './JIFxzHyW8W' is a path.
I visited mercury.picoctf.net:55336/JIFxzHyW8W and it gave a WebAssembly file.
I translate the wasm file to wat and analyze the result.
Now I translate to pseudo-code and analyze the result.
We can see that check_flag stayed pretty much the same as last time, so we can assume that the magic happens in copy. If we diff it against the previous implementation (which simply stored the provided flag characters in memory without any extra manipulation) we can see that the new version includes some extra logic.
What seems to be happening here is that characters from the flag are getting XORed with 8 before being saved at offset 1072+. We can also see that the string that check_flag uses to compare the user input to the expected flag (at offset 1024+) doesn't contain the flag in the clear anymore.
",analysis,0,Topic 0
01_simplewaf,web,"After reading the source code, there are 2 question come to my mind.
How to bypass the includes condition? (absolutely... that what we are looking for), and
What type of argument the readFileSync function can take to read a file?
By going around on Google, I found a write up for NodeJS Bypass Filter CTF, which is similar to this challenge at some point:
Both challenge doesn't validate the type of input, which means we can pass input as an array instead of a string, and
Both challenge require to bypass the includes function to reach the flag!
",analysis,0,Topic 0
01_simplewaf,web,"Why can't it bypass the waf? Well, I figure out there is a critial different point between the challenge at this line of code
(item) => item && JSON.stringify(item).includes(""flag"")
The simplewaf doesn't take the raw input to perform input validation, but transform the raw input a JSON string beforehand. So, the includes function still can check whether the transformed string contains flag or not.
At this point, I can't think of anyway to bypass the includes function... So, I move to the second question, and take a look at NodeJS document of that function.
Oke, so the path parameter can be either a <string> | <Buffer> | <URL> | <integer>. However, the type of requests query value is always string. How could we pass in the readFileSync function a URL, or an integer, or anything else other than a string?
",analysis,0,Topic 0
01_simplewaf,web,"Stopping fruitless effort at guessing, I decided to take a closer look of the readFileSync function at NodeJS source code on github.
The code snippet from line 469 and below perform read file process, which is nothing to dive in. The main point we need to dive in is the code at line 467. Follow the code by investigating the fs.openSync function.
Continue following by investigating the getValidatedPath function.
Hold down, some interesting things appear at here. So if the fileURLOrPath value is not null, and there are exists href and origin in it, it will call to fileURLToPath, which transform the fileURLOrPath value to a URL. That is the point! I can feel that I'm going on the right way!
Gaining momemtum, I continue investigating the fileURLToPath function.
One additional condition for the fileURLOrPath value is that its protocol must be file:.
After all of the check is passed, it will call the corresponding function to get path from the URL. Since I'm debugging on Linux, so I continue investigating at the getPathFromURLPosix function.
Once again, another check occurs at this code snippet: the hostname must be empty. But, one remarkable things to note down here, and it will helps us bypass the includes check of simplewaf is that it will perform URL decode on the pathname to get the URL. This means if we pass a double URL encoded pathname value from the web application, it will ends up the file path being plaintext. And guess what? Since the value pass the client to the includes check is just URL decoded once, we can easily bypass this check also.
Okay, let's sum it up all the things we need to do to pass a valid argument file as a URL into the readFileSync function.
file is not null
file.origin exists
file.href exists
file.protocol = 'file:'
file.hostname = ''
And the final requirement to bypass the waf and get the flag is:
file.pathname is double URL encoded
",analysis,0,Topic 0
02_friends,web,"The code is nearly 300 lines... There is a login function, follow and unfollow function, and our target is making admin follow us.
The source code does not contains any snippet of code that stored the credentials of admin user. 
Thought that the code could be hidden, or unprovided, I try to follow admin, but the application response ""user does not exist"". How strange it could be!
So... there is no admin account. Then just create an admin account, then follow other account. However, we can create an admin account, as the username must be at least 6 characters.
At this point, I got stuck. I found no entry point in code that we can input to edit followers data.
After reading the write up from the others, I found that I misunderstood a snippet of code.
Put it on prettier.io to see how this snippet of code actually look like. 
It completely change everything. Beforehand, body.u, body.r and body.n seems to be the return value of map function, turns out to be index of a users' followers array. 
The comma is now become the command operator.
Let's take a small demo to understand comma operator behavior in array index. 
Assume that arr = followers.get(req.username), the following code snippet will help us understand the behavior of comamnd operator.
There are 2 things to notice from the results we get:
We can assign the javascript array at any index. There is no line of code assign value for arr[0], but the js code still run without any error!
In case there is comma operator in array index, only the last index get the assigned value, and other get undefined.
At this point, you might think that: ""Alright, now I can just assign admin to the first index, then I can succesfully get the flag. My payload will be [body.u, body.r, body.n] = [""admin"", """", 1]. 
Unfortunately, this payload will not work because the inserted value is an array, not a string that we want.
The remaining problem is that by somehow, there is an element in followers array is value type of string, not array.
This magic will completely solve the remaining problems. Talking about __proto__ is long, so I will not do it at this write up. 
Let's examine the following snippet of code to understand the behavior of array __proto__.
There are 2 things to notice from the results we get:
Although there is no line of code assign value for arr1[0], the output of arr1 show that arr1[0]=""1"". This happens similar to arr2.
The filled up missing value is the same as the value we assigned to arr1[""__proto__""] or arr2[""__proto__""], sequentially.
Gotcha! At this point, we can finally solve the challenge, as we finally fill up the missing value with a controlled value and type, no matter what data is inserted in later!. Let's check it out!
",analysis,0,Topic 0
Friends,web,"The code is nearly 300 lines... There is a login function, follow and unfollow function, and our target is making admin follow us.
The source code does not contains any snippet of code that stored the credentials of admin user. 
Thought that the code could be hidden, or unprovided, I try to follow admin, but the application response ""user does not exist"". How strange it could be!
So... there is no admin account. Then just create an admin account, then follow other account. However, we can create an admin account, as the username must be at least 6 characters.
At this point, I got stuck. I found no entry point in code that we can input to edit followers data.
After reading the write up from the others, I found that I misunderstood a snippet of code.
Put it on prettier.io to see how this snippet of code actually look like. 
It completely change everything. Beforehand, body.u, body.r and body.n seems to be the return value of map function, turns out to be index of a users' followers array. 
The comma is now become the command operator.
Let's take a small demo to understand comma operator behavior in array index. 
Assume that arr = followers.get(req.username), the following code snippet will help us understand the behavior of comamnd operator.
There are 2 things to notice from the results we get:
We can assign the javascript array at any index. There is no line of code assign value for arr[0], but the js code still run without any error!
In case there is comma operator in array index, only the last index get the assigned value, and other get undefined.
At this point, you might think that: ""Alright, now I can just assign admin to the first index, then I can succesfully get the flag. My payload will be [body.u, body.r, body.n] = [""admin"", """", 1]. 
Unfortunately, this payload will not work because the inserted value is an array, not a string that we want.
The remaining problem is that by somehow, there is an element in followers array is value type of string, not array.
This magic will completely solve the remaining problems. Talking about __proto__ is long, so I will not do it at this write up. 
Let's examine the following snippet of code to understand the behavior of array __proto__.
There are 2 things to notice from the results we get:
Although there is no line of code assign value for arr1[0], the output of arr1 show that arr1[0]=""1"". This happens similar to arr2.
The filled up missing value is the same as the value we assigned to arr1[""__proto__""] or arr2[""__proto__""], sequentially.
Gotcha! At this point, we can finally solve the challenge, as we finally fill up the missing value with a controlled value and type, no matter what data is inserted in later!. Let's check it out!
",analysis,0,Topic 0
19_Most_Cookies,web,"I found that if you entered a cookie name given in the cookie name list (view line 7 in the server.py code), you will go into the first if statement but completely miss the nested if.
From this, it is clear we need to become admin to swipe that flag!
Let's visit the given site.
Use our old friend inspect > Application > Storage > Cookies
From there, we see a cookie named session.
You can view more information here for the details of each cookie value segment.
Let's go to https://jwt.io/ to decode that cookie value ... we observe that the header is { ""very_auth"": ""blank"" }
Yikes. We want to be ""admin"" instead of ""blank""
Another thing to point out on that site is that there is a ""verify signature"" section. Since flask cookies involve encryption, there is a secret key set to protect against attackers.
The app’s secret key is used to sign a flask session cookie so that it cannot be modified. However, since we know the secret key is one of the 28 cookie names, we can simply try them all until we successfully decrypt the cookie.
",analysis,0,Topic 0
24_Client-side-again,web,"We see that _0x4b5b is a function used to obfuscate different values. It is calculated in runtime. Luckily, we can use the browser's Javascript console (""Developer Tools"") in order to evaluate _0x4b5b and read its values.
Let's replace the function calls with hardcoded values to improve readability.
So this is very similar to dont-use-client-side, using substring to authenticate the password.
We have some substrings composing the flag.
Notice that there are some overlaps.
",analysis,0,Topic 0
23_picobrowser,web,"That string of text is known as a User-Agent and it tells the server what browser you're using.
",analysis,0,Topic 0
09_dont-use-client-side,web,"As referenced by the problem name, we assume that the check for the validity of the credentials is checked locally, and hence can be reversed to obtain the correct password. Checking the html source code gives us:
The checkpass variable holds our input, and the each substring method in this case gets us split(set to 4) number of characters starting from the first argument to the method. 
",analysis,0,Topic 0
JAuth,web,"Let’s look at the login HTTP request.
Nothing interesting. If we get set “Remember me” on we get the same request. Let’s check our cookies.
This is a JWT token. Let’s decode it.
We have a role part that is set to “user”. If we were to set it to admin, maybe we could log in as admin. I used https://jwt.io to encode it and we get.
",analysis,0,Topic 0
Irish-Name-Repo3,web,"Try to see if you can login as admin!
Since the password is hinted to be encrypted, we first check the page source for any signs of encryption to the input, however, do not see any. 
This means the encryption must be taking place server side.
We want to leak the encryption method somehow, so we open BurpSuite to monitor the requests made to the site. 
We input some string and submit the request. In BurpSuite, we notice a debug parameter, originally set to 0.
We change this to a 1, and forward the request. Now in addition to the Login failed page, we get some debug info:
The 'encryption' method used is just ROT13! We can thus craft our payloads normally, just running it through a ROT13 converter before sending it through.
",analysis,0,Topic 0
